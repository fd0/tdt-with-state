Table-Driven Tests With State
26 Jun 2018

Alexander Neumann
alexander@bumpern.de
https://github.com/fd0

* Table-Driven Tests

* A sample function

.code simple/main.go /^// Capitalize/,/^}/

* Testing Capitalize

.code simple/main_test.go /^func TestNormal/,/^}/

    $ go test -v -run TestNormal
    === RUN   TestNormal
    --- PASS: TestNormal (0.00s)
    PASS

: But what about non-ASCII characters?
: Like, for the string "Österreich"

* Testing Capitalize with More Cases

.code simple/main_test.go /^func TestFail/,/^}/

    $ go test -v -run TestFail
    === RUN   TestFail
    --- FAIL: TestFail (0.00s)
        main_test.go:30: wrong result, want "Österreich", got "österreich"
    FAIL

* Testing with Tables

.code simple/main_test.go /^func TestTables/,/^}/

* 
    $ go test -v -run TestTables
    === RUN   TestTables
    --- FAIL: TestTables (0.00s)
        main_test.go:47: wrong result, want "Österreich", got "österreich"
    FAIL

* Testing with Tables and Sub-Tests

.code simple/main_test.go /^func TestSubtests/,/^}/

* 
    $ go test -v -run TestSubtests
    === RUN   TestSubtests
    === RUN   TestSubtests/#00
    === RUN   TestSubtests/#01
    === RUN   TestSubtests/#02
    --- FAIL: TestSubtests (0.00s)
        --- PASS: TestSubtests/#00 (0.00s)
        --- PASS: TestSubtests/#01 (0.00s)
        --- FAIL: TestSubtests/#02 (0.00s)
            main_test.go:66: wrong result, want "Österreich", got "österreich"
    FAIL

: easier to recognize which test failed
: easy to re-run a single test

* Spot Failing Test Cases

    $ go test -run TestSubtests
    --- FAIL: TestSubtests (0.00s)
        --- FAIL: TestSubtests/#02 (0.00s)
            main_test.go:66: wrong result, want "Österreich", got "österreich"
    FAIL

* Re-Run Single Sub-Test

    $ go test -v -run TestSubtests/02
    === RUN   TestSubtests
    === RUN   TestSubtests/#02
    --- FAIL: TestSubtests (0.00s)
        --- FAIL: TestSubtests/#02 (0.00s)
            main_test.go:66: wrong result, want "Österreich", got "österreich"
    FAIL

* Real Example: Testing a Simple HTTP API

* API

Store, retrieve, and delete files of arbitrary types via HTTP:

- GET /{type}/{name}
- POST /{type}/{name}
- DELETE /{type}/{name}

Server can be run in two modes:

- regular mode: delete files of any type
- append-only mode: disallow deleting all files except type "lock"

* Example: Usage with cURL

    $ go build ./rest
    $ ./rest
    listen on localhost:1234 (append-only mode: false)

    $ curl -i -d "file content here" http://localhost:1234/text/file.txt
    HTTP/1.1 201 Created

    $ curl -i http://localhost:1234/text/file.txt
    HTTP/1.1 200 OK
    Content-Length: 17

    file content here

    $ curl -i -X DELETE http://localhost:1234/text/file.txt
    HTTP/1.1 200 OK

    $ curl -i http://localhost:1234/text/file.txt
    HTTP/1.1 404 Not Found

* Example: Usage with cURL in Append-Only Mode

    $ ./rest --append-only
    listen on localhost:1234 (append-only mode: false)

    $ curl -d "file content here" http://localhost:1234/text/file.txt

    $ curl http://localhost:1234/text/file.txt
    file content here

    $ curl -i -X DELETE http://localhost:1234/text/file.txt
    HTTP/1.1 405 Method Not Allowed

* Example: Usage with cURL in Append-Only Mode #2

    $ curl -d "file content here" http://localhost:1234/lock/foo

    $ curl http://localhost:1234/lock/foo
    file content here

    $ curl -i -X DELETE http://localhost:1234/lock/foo
    HTTP/1.1 200 OK

* Implementation: Type Server

.code rest/main.go /func NewServer/,/^}/

    func (s *Server) ServeHTTP(res http.ResponseWriter, req *http.Request) {
        [...]
    }

- The type `*Server` implements `http.Handler`
- Files are stored in a map in memory

* Testing Server

Strategy:

- Create new file
- Access it
- Delete it
- Try to access it again
- Repeat with type `lock`
- Repeat all in append-only mode

* Helpers

.code rest/regular_test.go /^func DoRequest/,/^}/

.code rest/regular_test.go /^func CheckStatus/,/^}/

.code rest/regular_test.go /^func CheckBody/,/^}/

* Testing the REST API Server

.code rest/regular_test.go /^func TestCreateDeleteFile/,/^}/

* Testing Append-Only Mode

.code rest/regular_test.go /^func TestAppendOnlyCreateDeleteFile/,/^}/

* 

Pros:

- Easy to read
- When test fails, the line number provides the exactly location

Cons:

- Much boilerplate code
- Not easy to add a new test case
- Need to find a name for the `TestXXX` function

* New Helper

.code rest/tables_test.go /^func NewRequest/,/^}/

* Table-Driven Tests

.code rest/tables_test.go /START INTRO/,/END INTRO/

* 
.code rest/tables_test.go /START FUNC/,/END FUNC/

* Testing in Regular Mode

.code rest/tables_test.go /START REGULAR/,/END/

* Test for Append-Only Mode

.code rest/tables_test.go /START APPEND1/,/END/

* Test for Append-Only Mode

.code rest/tables_test.go /START APPEND2/,/END/


* 

Pros:

- Test cases easy to read
- Adding new test case is easy

Cons:

- Test logic is more complicated
- Adding things to test for will clutter the code

* Idea

- Read standard library
- Discover patterns used there
- Use closure and return a function to check

* New Types and Helpers

.code rest/closures_test.go /^type CheckFunc/,/$/

.code rest/closures_test.go /^func WantStatus/,/^}/

.code rest/closures_test.go /^func WantBody/,/^}/

* 

.code rest/closures_test.go /START INTRO/,/END INTRO/

* 

.code rest/closures_test.go /START FUNC/,/END FUNC/

* Testing in Regular Mode

.code rest/closures_test.go /START REGULAR/,/END/

* Test for Append-Only Mode

.code rest/closures_test.go /START APPEND1/,/END/

* Test for Append-Only Mode

.code rest/closures_test.go /START APPEND2/,/END/

* 

Pros:

- Test cases easy to read
- Adding new test case is easy
- Test logic is simple
- Adding things to test for is easy

Cons:

- Higher overall complexity

* Testing for HTTP Header

.code rest/closures_test.go /^func WantHeader/,/^}/

* 

.code rest/closures_test.go /START HEADER/,/END/
